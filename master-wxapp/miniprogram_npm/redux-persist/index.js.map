{"version":3,"sources":["index.js","persistReducer.js","constants.js","stateReconciler\\autoMergeLevel1.js","createPersistoid.js","getStoredState.js","purgeStoredState.js","persistCombineReducers.js","stateReconciler\\autoMergeLevel2.js","persistStore.js","createMigrate.js","createTransform.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA;ADIA,AFMA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,AJYA,ACHA,AENA;ADIA,AENA,ACHA,ALeA,ACHA,AENA;ADIA,AENA,ACHA,ALeA,ACHA,AENA;ACFA,ACHA,ALeA,ACHA,AENA;ACFA,ACHA,ALeA,ACHA,AKfA,AHSA;ACFA,ACHA,ALeA,ACHA,AKfA,AHSA;ACFA,ACHA,ALeA,ACHA,AKfA,AHSA;ACFA,ACHA,ALeA,AOrBA,ANkBA,AKfA,AHSA;ACFA,ACHA,ALeA,AOrBA,ANkBA,AKfA,AHSA;ACFA,ACHA,ALeA,AOrBA,ANkBA,AKfA,AHSA;ACFA,ACHA,ALeA,AOrBA,ANkBA,AKfA,AHSA,AKfA;AJaA,ACHA,ALeA,AOrBA,ANkBA,AKfA,AHSA,AKfA;AJaA,ACHA,ALeA,AOrBA,ANkBA,AKfA,AHSA,AKfA;AJaA,ACHA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AJaA,ACHA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AJaA,ACHA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,ACHA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,ACHA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,ACHA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,AHSA,AHSA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,AOrBA,ANkBA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ANkBA,AKfA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,ANkBA,ALeA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AOrBA,AXiCA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA,ADGA;AELA,ANkBA,AJYA,ACHA,AQxBA;ACFA,ANkBA,AJYA,ACHA,AQxBA;ACFA,ANkBA,AJYA,ACHA,AQxBA;ACFA,ANkBA,AJYA,ACHA,AQxBA;ACFA,ANkBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AJYA,ACHA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ALgBA,AHSA,AQxBA;ARyBA,AQxBA;ARyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _persistReducer = require('./persistReducer');\n\nObject.defineProperty(exports, 'persistReducer', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_persistReducer).default;\n  }\n});\n\nvar _persistCombineReducers = require('./persistCombineReducers');\n\nObject.defineProperty(exports, 'persistCombineReducers', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_persistCombineReducers).default;\n  }\n});\n\nvar _persistStore = require('./persistStore');\n\nObject.defineProperty(exports, 'persistStore', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_persistStore).default;\n  }\n});\n\nvar _createMigrate = require('./createMigrate');\n\nObject.defineProperty(exports, 'createMigrate', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_createMigrate).default;\n  }\n});\n\nvar _createTransform = require('./createTransform');\n\nObject.defineProperty(exports, 'createTransform', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_createTransform).default;\n  }\n});\n\nvar _getStoredState = require('./getStoredState');\n\nObject.defineProperty(exports, 'getStoredState', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_getStoredState).default;\n  }\n});\n\nvar _createPersistoid = require('./createPersistoid');\n\nObject.defineProperty(exports, 'createPersistoid', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_createPersistoid).default;\n  }\n});\n\nvar _purgeStoredState = require('./purgeStoredState');\n\nObject.defineProperty(exports, 'purgeStoredState', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_purgeStoredState).default;\n  }\n});\n\nvar _constants = require('./constants');\n\nObject.keys(_constants).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _constants[key];\n    }\n  });\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = persistReducer;\n\nvar _constants = require('./constants');\n\nvar _autoMergeLevel = require('./stateReconciler/autoMergeLevel1');\n\nvar _autoMergeLevel2 = _interopRequireDefault(_autoMergeLevel);\n\nvar _createPersistoid = require('./createPersistoid');\n\nvar _createPersistoid2 = _interopRequireDefault(_createPersistoid);\n\nvar _getStoredState = require('./getStoredState');\n\nvar _getStoredState2 = _interopRequireDefault(_getStoredState);\n\nvar _purgeStoredState = require('./purgeStoredState');\n\nvar _purgeStoredState2 = _interopRequireDefault(_purgeStoredState);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nvar DEFAULT_TIMEOUT = 5000;\n/*\n  @TODO add validation / handling for:\n  - persisting a reducer which has nested _persist\n  - handling actions that fire before reydrate is called\n*/\nfunction persistReducer(config, baseReducer) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!config) throw new Error('config is required for persistReducer');\n    if (!config.key) throw new Error('key is required in persistor config');\n    if (!config.storage) throw new Error(\"redux-persist: config.storage is required. Try using one of the provided storage engines `import storage from 'redux-persist/lib/storage'`\");\n  }\n\n  var version = config.version !== undefined ? config.version : _constants.DEFAULT_VERSION;\n  var debug = config.debug || false;\n  var stateReconciler = config.stateReconciler === undefined ? _autoMergeLevel2.default : config.stateReconciler;\n  var getStoredState = config.getStoredState || _getStoredState2.default;\n  var timeout = config.timeout !== undefined ? config.timeout : DEFAULT_TIMEOUT;\n  var _persistoid = null;\n  var _purge = false;\n  var _paused = true;\n  var conditionalUpdate = function conditionalUpdate(state) {\n    // update the persistoid only if we are rehydrated and not paused\n    state._persist.rehydrated && _persistoid && !_paused && _persistoid.update(state);\n    return state;\n  };\n\n  return function (state, action) {\n    var _ref = state || {},\n        _persist = _ref._persist,\n        rest = _objectWithoutProperties(_ref, ['_persist']);\n\n    var restState = rest;\n\n    if (action.type === _constants.PERSIST) {\n      var _sealed = false;\n      var _rehydrate = function _rehydrate(payload, err) {\n        // dev warning if we are already sealed\n        if (process.env.NODE_ENV !== 'production' && _sealed) console.error('redux-persist: rehydrate for \"' + config.key + '\" called after timeout.', payload, err);\n\n        // only rehydrate if we are not already sealed\n        if (!_sealed) {\n          action.rehydrate(config.key, payload, err);\n          _sealed = true;\n        }\n      };\n      timeout && setTimeout(function () {\n        !_sealed && _rehydrate(undefined, new Error('redux-persist: persist timed out for persist key \"' + config.key + '\"'));\n      }, timeout);\n\n      // @NOTE PERSIST resumes if paused.\n      _paused = false;\n\n      // @NOTE only ever create persistoid once, ensure we call it at least once, even if _persist has already been set\n      if (!_persistoid) _persistoid = (0, _createPersistoid2.default)(config);\n\n      // @NOTE PERSIST can be called multiple times, noop after the first\n      if (_persist) return state;\n      if (typeof action.rehydrate !== 'function' || typeof action.register !== 'function') throw new Error('redux-persist: either rehydrate or register is not a function on the PERSIST action. This can happen if the action is being replayed. This is an unexplored use case, please open an issue and we will figure out a resolution.');\n\n      action.register(config.key);\n\n      getStoredState(config).then(function (restoredState) {\n        var migrate = config.migrate || function (s, v) {\n          return Promise.resolve(s);\n        };\n        migrate(restoredState, version).then(function (migratedState) {\n          _rehydrate(migratedState);\n        }, function (migrateErr) {\n          if (process.env.NODE_ENV !== 'production' && migrateErr) console.error('redux-persist: migration error', migrateErr);\n          _rehydrate(undefined, migrateErr);\n        });\n      }, function (err) {\n        _rehydrate(undefined, err);\n      });\n\n      return _extends({}, baseReducer(restState, action), {\n        _persist: { version: version, rehydrated: false }\n      });\n    } else if (action.type === _constants.PURGE) {\n      _purge = true;\n      action.result((0, _purgeStoredState2.default)(config));\n      return _extends({}, baseReducer(restState, action), {\n        _persist: _persist\n      });\n    } else if (action.type === _constants.FLUSH) {\n      action.result(_persistoid && _persistoid.flush());\n      return _extends({}, baseReducer(restState, action), {\n        _persist: _persist\n      });\n    } else if (action.type === _constants.PAUSE) {\n      _paused = true;\n    } else if (action.type === _constants.REHYDRATE) {\n      // noop on restState if purging\n      if (_purge) return _extends({}, restState, {\n        _persist: _extends({}, _persist, { rehydrated: true })\n\n        // @NOTE if key does not match, will continue to default else below\n      });if (action.key === config.key) {\n        var reducedState = baseReducer(restState, action);\n        var inboundState = action.payload;\n        // only reconcile state if stateReconciler and inboundState are both defined\n        var reconciledRest = stateReconciler !== false && inboundState !== undefined ? stateReconciler(inboundState, state, reducedState, config) : reducedState;\n\n        var _newState = _extends({}, reconciledRest, {\n          _persist: _extends({}, _persist, { rehydrated: true })\n        });\n        return conditionalUpdate(_newState);\n      }\n    }\n\n    // if we have not already handled PERSIST, straight passthrough\n    if (!_persist) return baseReducer(state, action);\n\n    // run base reducer:\n    // is state modified ? return original : return updated\n    var newState = baseReducer(restState, action);\n    if (newState === restState) return state;else {\n      newState._persist = _persist;\n      return conditionalUpdate(newState);\n    }\n  };\n}","'use strict';\n\nexports.__esModule = true;\nvar KEY_PREFIX = exports.KEY_PREFIX = 'persist:';\nvar FLUSH = exports.FLUSH = 'persist/FLUSH';\nvar REHYDRATE = exports.REHYDRATE = 'persist/REHYDRATE';\nvar PAUSE = exports.PAUSE = 'persist/PAUSE';\nvar PERSIST = exports.PERSIST = 'persist/PERSIST';\nvar PURGE = exports.PURGE = 'persist/PURGE';\nvar REGISTER = exports.REGISTER = 'persist/REGISTER';\nvar DEFAULT_VERSION = exports.DEFAULT_VERSION = -1;","'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = autoMergeLevel1;\nfunction autoMergeLevel1(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      // otherwise hard set the new value\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n\n  return newState;\n}\n\n/*\n  autoMergeLevel1: \n    - merges 1 level of substate\n    - skips substate if already modified\n*/","'use strict';\n\nexports.__esModule = true;\nexports.default = createPersistoid;\n\nvar _constants = require('./constants');\n\n// @TODO remove once flow < 0.63 support is no longer required.\n\nfunction createPersistoid(config) {\n  // defaults\n  var blacklist = config.blacklist || null;\n  var whitelist = config.whitelist || null;\n  var transforms = config.transforms || [];\n  var throttle = config.throttle || 0;\n  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX) + config.key;\n  var storage = config.storage;\n  var serialize = config.serialize === false ? function (x) {\n    return x;\n  } : defaultSerialize;\n\n  // initialize stateful values\n  var lastState = {};\n  var stagedState = {};\n  var keysToProcess = [];\n  var timeIterator = null;\n  var writePromise = null;\n\n  var update = function update(state) {\n    // add any changed keys to the queue\n    Object.keys(state).forEach(function (key) {\n      if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop\n      if (lastState[key] === state[key]) return; // value unchanged? noop\n      if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop\n      keysToProcess.push(key); // add key to queue\n    });\n\n    //if any key is missing in the new state which was present in the lastState,\n    //add it for processing too\n    Object.keys(lastState).forEach(function (key) {\n      if (state[key] === undefined) {\n        keysToProcess.push(key);\n      }\n    });\n\n    // start the time iterator if not running (read: throttle)\n    if (timeIterator === null) {\n      timeIterator = setInterval(processNextKey, throttle);\n    }\n\n    lastState = state;\n  };\n\n  function processNextKey() {\n    if (keysToProcess.length === 0) {\n      if (timeIterator) clearInterval(timeIterator);\n      timeIterator = null;\n      return;\n    }\n\n    var key = keysToProcess.shift();\n    var endState = transforms.reduce(function (subState, transformer) {\n      return transformer.in(subState, key, lastState);\n    }, lastState[key]);\n\n    if (endState !== undefined) {\n      try {\n        stagedState[key] = serialize(endState);\n      } catch (err) {\n        console.error('redux-persist/createPersistoid: error serializing state', err);\n      }\n    } else {\n      //if the endState is undefined, no need to persist the existing serialized content\n      delete stagedState[key];\n    }\n\n    if (keysToProcess.length === 0) {\n      writeStagedState();\n    }\n  }\n\n  function writeStagedState() {\n    // cleanup any removed keys just before write.\n    Object.keys(stagedState).forEach(function (key) {\n      if (lastState[key] === undefined) {\n        delete stagedState[key];\n      }\n    });\n\n    writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);\n  }\n\n  function passWhitelistBlacklist(key) {\n    if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false;\n    if (blacklist && blacklist.indexOf(key) !== -1) return false;\n    return true;\n  }\n\n  function onWriteFail(err) {\n    // @TODO add fail handlers (typically storage full)\n    if (err && process.env.NODE_ENV !== 'production') {\n      console.error('Error storing data', err);\n    }\n  }\n\n  var flush = function flush() {\n    while (keysToProcess.length !== 0) {\n      processNextKey();\n    }\n    return writePromise || Promise.resolve();\n  };\n\n  // return `persistoid`\n  return {\n    update: update,\n    flush: flush\n  };\n}\n\n// @NOTE in the future this may be exposed via config\n\n\nfunction defaultSerialize(data) {\n  return JSON.stringify(data);\n}","'use strict';\n\nexports.__esModule = true;\nexports.default = getStoredState;\n\nvar _constants = require('./constants');\n\nfunction getStoredState(config) {\n  var transforms = config.transforms || [];\n  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX) + config.key;\n  var storage = config.storage;\n  var debug = config.debug;\n  var deserialize = config.serialize === false ? function (x) {\n    return x;\n  } : defaultDeserialize;\n  return storage.getItem(storageKey).then(function (serialized) {\n    if (!serialized) return undefined;else {\n      try {\n        var state = {};\n        var rawState = deserialize(serialized);\n        Object.keys(rawState).forEach(function (key) {\n          state[key] = transforms.reduceRight(function (subState, transformer) {\n            return transformer.out(subState, key, rawState);\n          }, deserialize(rawState[key]));\n        });\n        return state;\n      } catch (err) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/getStoredState: Error restoring data ' + serialized, err);\n        throw err;\n      }\n    }\n  });\n}\n\nfunction defaultDeserialize(serial) {\n  return JSON.parse(serial);\n}","'use strict';\n\nexports.__esModule = true;\nexports.default = purgeStoredState;\n\nvar _constants = require('./constants');\n\nfunction purgeStoredState(config) {\n  var storage = config.storage;\n  var storageKey = '' + (config.keyPrefix !== undefined ? config.keyPrefix : _constants.KEY_PREFIX) + config.key;\n  return storage.removeItem(storageKey, warnIfRemoveError);\n}\n\nfunction warnIfRemoveError(err) {\n  if (err && process.env.NODE_ENV !== 'production') {\n    console.error('redux-persist/purgeStoredState: Error purging data stored state', err);\n  }\n}","'use strict';\n\nexports.__esModule = true;\nexports.default = persistCombineReducers;\n\nvar _redux = require('redux');\n\nvar _persistReducer = require('./persistReducer');\n\nvar _persistReducer2 = _interopRequireDefault(_persistReducer);\n\nvar _autoMergeLevel = require('./stateReconciler/autoMergeLevel2');\n\nvar _autoMergeLevel2 = _interopRequireDefault(_autoMergeLevel);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// combineReducers + persistReducer with stateReconciler defaulted to autoMergeLevel2\nfunction persistCombineReducers(config, reducers) {\n  config.stateReconciler = config.stateReconciler === undefined ? _autoMergeLevel2.default : config.stateReconciler;\n  return (0, _persistReducer2.default)(config, (0, _redux.combineReducers)(reducers));\n}","'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = autoMergeLevel2;\nfunction autoMergeLevel2(inboundState, originalState, reducedState, _ref) {\n  var debug = _ref.debug;\n\n  var newState = _extends({}, reducedState);\n  // only rehydrate if inboundState exists and is an object\n  if (inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') {\n    Object.keys(inboundState).forEach(function (key) {\n      // ignore _persist data\n      if (key === '_persist') return;\n      // if reducer modifies substate, skip auto rehydration\n      if (originalState[key] !== reducedState[key]) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist/stateReconciler: sub state for key `%s` modified, skipping.', key);\n        return;\n      }\n      if (isPlainEnoughObject(reducedState[key])) {\n        // if object is plain enough shallow merge the new values (hence \"Level2\")\n        newState[key] = _extends({}, newState[key], inboundState[key]);\n        return;\n      }\n      // otherwise hard set\n      newState[key] = inboundState[key];\n    });\n  }\n\n  if (process.env.NODE_ENV !== 'production' && debug && inboundState && (typeof inboundState === 'undefined' ? 'undefined' : _typeof(inboundState)) === 'object') console.log('redux-persist/stateReconciler: rehydrated keys \\'' + Object.keys(inboundState).join(', ') + '\\'');\n\n  return newState;\n}\n\n/*\n  autoMergeLevel2: \n    - merges 2 level of substate\n    - skips substate if already modified\n    - this is essentially redux-perist v4 behavior\n*/\n\nfunction isPlainEnoughObject(o) {\n  return o !== null && !Array.isArray(o) && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object';\n}","'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = persistStore;\n\nvar _redux = require('redux');\n\nvar _persistReducer = require('./persistReducer');\n\nvar _persistReducer2 = _interopRequireDefault(_persistReducer);\n\nvar _constants = require('./constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar initialState = {\n  registry: [],\n  bootstrapped: false\n};\n\nvar persistorReducer = function persistorReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments[1];\n\n  switch (action.type) {\n    case _constants.REGISTER:\n      return _extends({}, state, { registry: [].concat(_toConsumableArray(state.registry), [action.key]) });\n    case _constants.REHYDRATE:\n      var firstIndex = state.registry.indexOf(action.key);\n      var registry = [].concat(_toConsumableArray(state.registry));\n      registry.splice(firstIndex, 1);\n      return _extends({}, state, { registry: registry, bootstrapped: registry.length === 0 });\n    default:\n      return state;\n  }\n};\n\nfunction persistStore(store, options, cb) {\n  // help catch incorrect usage of passing PersistConfig in as PersistorOptions\n  if (process.env.NODE_ENV !== 'production') {\n    var optionsToTest = options || {};\n    var bannedKeys = ['blacklist', 'whitelist', 'transforms', 'storage', 'keyPrefix', 'migrate'];\n    bannedKeys.forEach(function (k) {\n      if (!!optionsToTest[k]) console.error('redux-persist: invalid option passed to persistStore: \"' + k + '\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.');\n    });\n  }\n  var boostrappedCb = cb || false;\n\n  var _pStore = (0, _redux.createStore)(persistorReducer, initialState, options ? options.enhancer : undefined);\n  var register = function register(key) {\n    _pStore.dispatch({\n      type: _constants.REGISTER,\n      key: key\n    });\n  };\n\n  var rehydrate = function rehydrate(key, payload, err) {\n    var rehydrateAction = {\n      type: _constants.REHYDRATE,\n      payload: payload,\n      err: err,\n      key: key\n      // dispatch to `store` to rehydrate and `persistor` to track result\n    };store.dispatch(rehydrateAction);\n    _pStore.dispatch(rehydrateAction);\n    if (boostrappedCb && persistor.getState().bootstrapped) {\n      boostrappedCb();\n      boostrappedCb = false;\n    }\n  };\n\n  var persistor = _extends({}, _pStore, {\n    purge: function purge() {\n      var results = [];\n      store.dispatch({\n        type: _constants.PURGE,\n        result: function result(purgeResult) {\n          results.push(purgeResult);\n        }\n      });\n      return Promise.all(results);\n    },\n    flush: function flush() {\n      var results = [];\n      store.dispatch({\n        type: _constants.FLUSH,\n        result: function result(flushResult) {\n          results.push(flushResult);\n        }\n      });\n      return Promise.all(results);\n    },\n    pause: function pause() {\n      store.dispatch({\n        type: _constants.PAUSE\n      });\n    },\n    persist: function persist() {\n      store.dispatch({ type: _constants.PERSIST, register: register, rehydrate: rehydrate });\n    }\n  });\n\n  persistor.persist();\n\n  return persistor;\n}","'use strict';\n\nexports.__esModule = true;\nexports.default = createMigrate;\n\nvar _constants = require('./constants');\n\nfunction createMigrate(migrations, config) {\n  var _ref = config || {},\n      debug = _ref.debug;\n\n  return function (state, currentVersion) {\n    if (!state) {\n      if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist: no inbound state, skipping migration');\n      return Promise.resolve(undefined);\n    }\n\n    var inboundVersion = state._persist && state._persist.version !== undefined ? state._persist.version : _constants.DEFAULT_VERSION;\n    if (inboundVersion === currentVersion) {\n      if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist: versions match, noop migration');\n      return Promise.resolve(state);\n    }\n    if (inboundVersion > currentVersion) {\n      if (process.env.NODE_ENV !== 'production') console.error('redux-persist: downgrading version is not supported');\n      return Promise.resolve(state);\n    }\n\n    var migrationKeys = Object.keys(migrations).map(function (ver) {\n      return parseInt(ver);\n    }).filter(function (key) {\n      return currentVersion >= key && key > inboundVersion;\n    }).sort(function (a, b) {\n      return a - b;\n    });\n\n    if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist: migrationKeys', migrationKeys);\n    try {\n      var migratedState = migrationKeys.reduce(function (state, versionKey) {\n        if (process.env.NODE_ENV !== 'production' && debug) console.log('redux-persist: running migration for versionKey', versionKey);\n        return migrations[versionKey](state);\n      }, state);\n      return Promise.resolve(migratedState);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  };\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = createTransform;\nfunction createTransform(\n// @NOTE inbound: transform state coming from redux on its way to being serialized and stored\ninbound,\n// @NOTE outbound: transform state coming from storage, on its way to be rehydrated into redux\noutbound) {\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var whitelist = config.whitelist || null;\n  var blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: function _in(state, key, fullState) {\n      return !whitelistBlacklistCheck(key) && inbound ? inbound(state, key, fullState) : state;\n    },\n    out: function out(state, key, fullState) {\n      return !whitelistBlacklistCheck(key) && outbound ? outbound(state, key, fullState) : state;\n    }\n  };\n}"]}